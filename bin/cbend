#!/usr/bin/env node

const program = require('commander');
const mkdirp = require('mkdirp');
const os = require('os');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const sortedObject = require('sorted-object');
const _exit = process.exit;
const eol = os.EOL;
const pkg = require('../package.json');
const version = pkg.version;
const u_struct = require('../utils/structure')
const prompt = require('../utils/prompt')

// Re-assign process.exit because of commander
// TODO: Switch to a different command framework
process.exit = exit

// CLI

before(program, 'outputHelp', function () {
    this.allowUnknownOption();
});

program
    .version(version)
    .usage('[options] [dir]')
    .option('    --git', 'add .gitignore')
    .option('-f, --force', 'force on non-empty directory')
    .parse(process.argv);

if (!exit.exited) {
    main();
}

/**
 * Install a before function; AOP.
 */

function before(obj, method, fn) {
    var old = obj[method];

    obj[method] = function () {
        fn.call(this);
        old.apply(this, arguments);
    };
}


/**
 * Create application at the given directory `path`.
 *
 * @param {String} path
 */

async function createApplication (app_name, path) {

    let dialect = await prompt.prompt_for_dialect()
    let tables = await prompt.capture_all_tables()
    let associations = await prompt.capture_all_associations(tables)
}


/**
 * Graceful exit for async STDIO
 */

function exit(code) {
    function done() {
        if (!(draining--)) _exit(code);
    }

    let draining = 0;
    let streams = [process.stdout, process.stderr];

    exit.exited = true;

    streams.forEach(function(stream){
        // submit empty write request and wait for completion
        draining += 1;
        stream.write('', done);
    });

    done();
}


/**
 * Main program.
 */

async function main() {
    // Path
    let destinationPath = program.args.shift() || '.';
    // App name
    let appName = path.basename(path.resolve(destinationPath));


    // Generate application
    let is_empty_dir = await u_struct.check_for_empty_directory(destinationPath)
    if (is_empty_dir || program.force) {
        createApplication(appName, destinationPath);
    } else {
        let ok = prompt.confirm('WARNING - destination is not empty, continue? [y/N] ')
        if (ok) {
            process.stdin.destroy();
            createApplication(appName, destinationPath);
        } else {
            console.error('aborting');
            exit(1);
        }
    }


}
